Debug: apply 3.

Debug: intro x.
apply x.

Debug: intros x y.
apply x.

Debug: intros H y.
apply y.

Debug: intros x H.
apply x.

Debug: intros H H0 x.
apply x.

Debug: apply @eq_refl.

Debug: reflexivity.

Debug: reflexivity.

Debug: apply (eq_rect (A:=nat)).

Debug: rewrite eq_refl.
apply tt.

Debug: rewrite <- eq_refl.
apply I.

Debug: intros x H.
rewrite H.
rewrite <- H.
reflexivity.

Debug: intros a b H H0.
rewrite H0 in H.
apply H.

Debug:
intros a b H H0.
rewrite H0 in H.
rewrite <- H0 in H.
rewrite H0 in H.
apply H.

Debug:
intros a b H H0.
apply (eq_ind b (fun b0 : nat => a = b0)
                          ((fun x : a = b => x) H) a) in H0.
reflexivity.

Debug:
intros a b H H0.
apply (eq_ind b (fun b0 : nat => a = b0) H a) in H0.
pose H as q'.
reflexivity.

Debug: intros a b H.
left.
apply H.

Debug: intros a b H.
right.
apply H.

Debug: intros a b H H0.
split.
- apply H.
- apply H0.

Debug: split.
- left.
  reflexivity.
- right.
  reflexivity.

Debug:
intro x.
induction x as [|x0 IHx].
- reflexivity.
- simpl.
  rewrite IHx.
  reflexivity.

Debug:
intros X xs ys zs.
revert ys zs.
induction xs as [|a xs0 IHxs].
- intros ys0 zs0.
  reflexivity.
- intros ys0 zs0.
  simpl.
  rewrite 
(IHxs ys0 zs0).
  reflexivity.

Debug:
intros P Q H.
induction H as [H0|H0].
- left.
  apply H0.
- right.
  apply H0.
