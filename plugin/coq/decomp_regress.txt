Debug: apply 3.

Debug: intro x.
apply x.

Debug: intros x y.
apply x.

Debug: intros H y.
apply y.

Debug: intros x H.
apply x.

Debug: intros H H0 x.
apply x.

Debug: apply @eq_refl.

Debug: reflexivity.

Debug: reflexivity.

Debug: apply (eq_rect (A:=nat)).

Debug: rewrite eq_refl.
apply tt.

Debug: rewrite <- eq_refl.
apply I.

Debug: intros x H.
rewrite H.
rewrite <- H.
reflexivity.

Debug: intros a b H H0.
rewrite H0 in H.
apply H.

Debug:
intros a b H H0.
rewrite H0 in H.
rewrite <- H0 in H.
rewrite H0 in H.
apply H.

Debug:
intros a b H H0.
apply (eq_ind b (fun b0 : nat => a = b0)
                          ((fun x : a = b => x) H) a) in H0.
reflexivity.

Debug:
intros a b H H0.
apply (eq_ind b (fun b0 : nat => a = b0) H a) in H0.
pose H as q'.
reflexivity.

Debug: intros a b H.
left.
apply H.

Debug: intros a b H.
right.
apply H.

Debug: intros a b H H0.
split.
apply H.
apply H0.

Debug: split.
left.
reflexivity.
right.
reflexivity.

